	TSTO #44
	BOV pile_pleine
	ADDSP #15
; table des methodes
; construction de la table des methodes de Object
	LOAD #null, R0
	STORE R0, 1(GB)
	LOAD code.Object.equals, R0
	STORE R0, 2(GB)
; construction de la table des methodes de point
	LEA 1(GB), R0
	STORE R0, 3(GB)
	LOAD code.point.getX, R0
	STORE R0, 5(GB)
	LOAD code.point.setY, R0
	STORE R0, 8(GB)
	LOAD code.point.getY, R0
	STORE R0, 6(GB)
	LOAD code.point.setX, R0
	STORE R0, 7(GB)
	LOAD code.point.distance, R0
	STORE R0, 9(GB)
	LOAD code.Object.equals, R0
	STORE R0, 4(GB)
; construction de la table des methodes de t
	LEA 1(GB), R0
	STORE R0, 10(GB)
	LOAD code.t.isRec, R0
	STORE R0, 12(GB)
	LOAD code.Object.equals, R0
	STORE R0, 11(GB)
; Main program
; Beginning of main instructions:
; instruction new
	NEW #4, R2
	LEA 10(GB), R0
	STORE R0, 0(R2)
	PUSH R2
	BSR init.t
	POP R2
	STORE R2, 13(GB)
	LOAD 13(GB), R3
	LOAD 2(R3), R3
	STORE R3, 14(GB)
	LOAD 13(GB), R3
	LOAD 1(R3), R3
	STORE R3, 15(GB)
; appel de methode4
	ADDSP #2
	LOAD 14(GB), R3
	STORE R3, 0(SP)
	LOAD #2, R4
	STORE R4, -1(SP)
	LOAD 0(SP), R3
	CMP #null, R3
	BEQ pile_pleine
	LOAD 0(R3), R3
	BSR 4(R3)
	SUBSP #2
	LOAD R0, R4
; appel de methode5
	ADDSP #2
	LOAD 13(GB), R5
	LOAD 3(R5), R5
	STORE R5, 0(SP)
	LOAD #4, R5
	STORE R5, -1(SP)
	LOAD 0(SP), R5
	CMP #null, R5
	BEQ pile_pleine
	LOAD 0(R5), R5
	BSR 5(R5)
	SUBSP #2
	LOAD R0, R5
; appel de methode6
	ADDSP #2
	LOAD 14(GB), R6
	STORE R6, 0(SP)
	LOAD 15(GB), R8
	STORE R8, -1(SP)
	LOAD 0(SP), R6
	CMP #null, R6
	BEQ pile_pleine
	LOAD 0(R6), R6
	BSR 6(R6)
	SUBSP #2
	LOAD R0, R8
	LOAD R8, R1
	WINT
	WNL
	HALT
init.point:
	LOAD #0, R0
	LOAD -2(LB), R1
	STORE R0, 1(R1)
	LOAD #0, R0
	LOAD -2(LB), R1
	STORE R0, 2(R1)
	RTS
code.point.getX:
	PUSH R8
	PUSH R6
	PUSH R5
	PUSH R4
	PUSH R3
	PUSH R2
	LOAD -2(LB), R1
	LOAD 1(R1), R6
	LOAD R6, R0
	POP R2
	POP R3
	POP R4
	POP R5
	POP R6
	POP R8
	RTS
code.point.getY:
	PUSH R9
	LOAD -2(LB), R1
	LOAD 2(R1), R9
	LOAD R9, R0
	POP R9
	RTS
code.point.setX:
	PUSH R10
	LOAD -3(LB), R10
	LOAD -2(LB), R1
	STORE R10, 1(R1)
	POP R10
	RTS
code.point.setY:
	PUSH R11
	LOAD -3(LB), R11
	LOAD -2(LB), R1
	STORE R11, 2(R1)
	POP R11
	RTS
code.point.distance:
	PUSH R15
	PUSH R14
	PUSH R13
	PUSH R12
	PUSH R11
	LOAD -2(LB), R11
	LOAD 1(R11), R11
; appel de methode2
	ADDSP #1
	LOAD -3(LB), R12
	STORE R12, 0(SP)
	LOAD 0(SP), R12
	CMP #null, R12
	BEQ pile_pleine
	LOAD 0(R12), R12
	BSR 2(R12)
	SUBSP #1
	LOAD R0, R13
	SUB R13, R11
	LOAD -2(LB), R13
	LOAD 1(R13), R13
; appel de methode2
	ADDSP #1
	LOAD -3(LB), R12
	STORE R12, 0(SP)
	LOAD 0(SP), R12
	CMP #null, R12
	BEQ pile_pleine
	LOAD 0(R12), R12
	BSR 2(R12)
	SUBSP #1
	LOAD R0, R14
	SUB R14, R13
	MUL R13, R11
	BOV over_flow
	LOAD -2(LB), R13
	LOAD 2(R13), R13
; appel de methode3
	ADDSP #1
	LOAD -3(LB), R14
	STORE R14, 0(SP)
	LOAD 0(SP), R14
	CMP #null, R14
	BEQ pile_pleine
	LOAD 0(R14), R14
	BSR 3(R14)
	SUBSP #1
	LOAD R0, R12
	SUB R12, R13
	LOAD -2(LB), R12
	LOAD 2(R12), R12
; appel de methode3
	ADDSP #1
	LOAD -3(LB), R14
	STORE R14, 0(SP)
	LOAD 0(SP), R14
	CMP #null, R14
	BEQ pile_pleine
	LOAD 0(R14), R14
	BSR 3(R14)
	SUBSP #1
	LOAD R0, R15
	SUB R15, R12
	MUL R12, R13
	BOV over_flow
	ADD R13, R11
	LOAD R11, R0
	POP R11
	POP R12
	POP R13
	POP R14
	POP R15
	RTS
init.t:
; instruction new
	NEW #3, R11
	LEA 3(GB), R0
	STORE R0, 0(R11)
	PUSH R11
	BSR init.point
	POP R11
	LOAD R11, R0
	LOAD -2(LB), R1
	STORE R0, 1(R1)
; instruction new
	NEW #3, R11
	LEA 3(GB), R0
	STORE R0, 0(R11)
	PUSH R11
	BSR init.point
	POP R11
	LOAD R11, R0
	LOAD -2(LB), R1
	STORE R0, 2(R1)
; instruction new
	NEW #3, R11
	LEA 3(GB), R0
	STORE R0, 0(R11)
	PUSH R11
	BSR init.point
	POP R11
	LOAD R11, R0
	LOAD -2(LB), R1
	STORE R0, 3(R1)
	RTS
code.t.isRec:
	PUSH R14
	PUSH R11
	PUSH R9
	PUSH R6
	PUSH R4
	PUSH R3
; appel de methode6
	ADDSP #2
	LOAD -2(LB), R1
	LOAD 1(R1), R12
	STORE R12, 0(SP)
	LOAD -2(LB), R1
	LOAD 2(R1), R14
	STORE R14, -1(SP)
	LOAD 0(SP), R12
	CMP #null, R12
	BEQ pile_pleine
	LOAD 0(R12), R12
	BSR 6(R12)
	SUBSP #2
	LOAD R0, R14
; appel de methode6
	ADDSP #2
	BOV pile_pleine
	PUSH R2
	LOAD -2(LB), R1
	LOAD 1(R1), R2
	STORE R2, 0(SP)
	BOV pile_pleine
	PUSH R3
	BOV pile_pleine
	PUSH R4
	LOAD -2(LB), R1
	LOAD 3(R1), R4
	STORE R4, -1(SP)
	POP R4
	LOAD 0(SP), R2
	CMP #null, R2
	BEQ pile_pleine
	LOAD 0(R2), R2
	BSR 6(R2)
	SUBSP #2
	BOV pile_pleine
	PUSH R3
	LOAD R0, R3
	POP R2
	ADD R3, R14
	POP R3
; appel de methode6
	ADDSP #2
	BOV pile_pleine
	PUSH R5
	BOV pile_pleine
	PUSH R7
	LOAD -2(LB), R1
	LOAD 3(R1), R7
	STORE R7, 0(SP)
	BOV pile_pleine
	PUSH R8
	BOV pile_pleine
	PUSH R6
	LOAD -2(LB), R1
	LOAD 2(R1), R6
	STORE R6, -1(SP)
	POP R6
	LOAD 0(SP), R7
	CMP #null, R7
	BEQ pile_pleine
	LOAD 0(R7), R7
	BSR 6(R7)
	SUBSP #2
	BOV pile_pleine
	PUSH R9
	LOAD R0, R9
	POP R7
	SUB R9, R14
	LOAD R14, R1
	BEQ OpCmp_if_in_a2611
	LOAD #1, R1
	BRA OpCmp_fin_in_a2611
OpCmp_if_in_a2611:
	LOAD #0, R1
OpCmp_fin_in_a2611:
	LOAD R1, R11
	LOAD R11, R1
	BNE IfThenElse_else_a2611
	WSTR "true"
	WNL
	BRA IfThenElse_fin_a2611
IfThenElse_else_a2611:
	WSTR "false"
	WNL
IfThenElse_fin_a2611:
	POP R3
	POP R4
	POP R6
	POP R9
	POP R11
	POP R14
	RTS
code.Object.equals:
pile_pleine:
	WSTR "Error: Stack Overflow"
	WNL
	ERROR
over_flow:
	WSTR "Error: Overflow during arithmetic operation"
	WNL
	ERROR
i0_error:
	WSTR "Error: Input/Output error"
	WNL
	ERROR
divisionErr:
	WSTR "Error :Division par 0"
	WNL
	ERROR
